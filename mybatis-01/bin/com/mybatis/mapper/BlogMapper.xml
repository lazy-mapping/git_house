<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.mybatis.mapper.BlogMapper">
	
	<!-- 起别名 -->
   <resultMap type="Blog" id="blogResultMap">
		<id column="id" property="id" jdbcType="INTEGER"></id>
		<association property="author" column="authorId" javaType="Author"
		select="com.mybatis.mapper.AuthorMapper.selectAuthorById"></association>
   </resultMap>
 	<select id="selectBlogById" parameterType="int" resultMap="blogResultMap">
 		select * from blog where id = #{id}
 	</select>
   
   <select id="selectBlogList" resultMap="blogResultMap">
 		select * from blog
 	</select>
   
	<!-- sql片段 ,可引用的重复代码-->
	<sql id="columnBase">
		id
		title,
    	authorId,
    	state,
    	style,
    	featured
    </sql>
	
	<!-- statement ,此处int是integer类型,resultType应该写全称 -->
	
	<!-- 这个查询，用了sql片段 -->
    <select id="selectBlog" parameterType="int" resultType="Blog">
        select 
        <include refid="columnBase"></include>
        from Blog where id = #{id}
    </select>
		
	<select id="selectBlogByTitle" parameterType="string" resultType="Blog">
		<!-- select * from blog where title like #{title} -->
		
		<!-- 此处，# 是占位符。$ 是字符串拼接。
			sql语句的 # 换  $ ,则改为 '%${value}%', % 放在语句中查询时就不用写了，有sql注入的风险  
			当参数表示表名、列名，只能用$   -->
		
		<!-- 不分大小写 -->
		select * from blog where lower(title) like lower(#{title})
	</select>
    
    <select id="selectBlogBySort" parameterType="string" resultType="Blog">
    	<!-- 当参数表示表名、列名，只能用$   --> 
    	<!-- select * from blog order by ${value}  排序，下面是汉字首字母排序-->
    	select * from blog order by convert(${value} using gbk)
    </select>
    
    <select id="selectBlogByPage"  resultType="Blog">
    	<!-- 方法1：索引   2：注解式，参数要一致 3：map,sql语句参数占位符与key一致  --> 
    	<!-- select * from blog limit #{0}, #{1} -->
    	<!-- select * from blog limit #{offset}, #{pagesize} -->
    	select * from blog limit #{offset}, #{pagesize}
    </select>
   
	<!-- 这个id是自增的，故不设置id值。
	useGeneratedKeys="true" keyProperty="id" 这两个属性设置id自增 ，不设置则id=null 
	方法1：此处设置 useGeneratedKeys="true"  
	方法2 ：全局配置useGeneratedKeys，即在cfg文件中配置settings选项 -->
    <insert id="insertBlog" parameterType="Blog"  keyProperty="id" >
        <!-- 设置Oracle数据库id不自增的情况   
  		<selectKey resultType="java.lang.Integer" order="BEFORE" keyProperty="id">
    		select seq.nextval as id from dual
    	</selectKey> -->
    	
    	<!-- Mysql，这句只适用id自增的情况？为什么写这个，似乎没用？
  		<selectKey resultType="java.lang.Integer" order="AFTER" keyProperty="id">
    		select LAST_INSERT_ID()
    	</selectKey>    -->
    	insert into blog(
    		title,
    		authorId,
    		state,
    		style,
    		featured
    		)
    		values (
    			#{title},
    			#{authorId},
    			#{state},
    			#{style},
    			#{featured}
    		)
    </insert>
    
    <!-- 此处可以写动态sql,更加灵活 -->
    <update id="updateBlog" parameterType="Blog" >
    	update blog set 
    		title    = #{title},
    		authorId = #{authorId},
    		state    = #{state},
    		style    = #{style},
    		featured = #{featured}
    	where id = #{id};
    </update>
    
    <delete id="deleteBlogById" parameterType="int">
    	delete from blog where id = #{id}
    </delete>
    
    <!-- 动态SQL  1.状态激活 & 2.检索title关键字 -->
    <select id="selectActiveBlogByTitle" parameterType="int" resultType="Blog">
    	select * from blog where state = 'ACTIVE'
    	<if test="value != null and value != '' ">
    		and title like '%${value}%'
    	</if>
    </select>
    
    <!-- 动态SQL  1.状态激活 & 2.检索title、style关键字 or featured关键字 -->
    <select id="selectActiveBlogByTitleOrStyle" parameterType="int" resultType="Blog">
    	select * from blog where state = 'ACTIVE'
    		<choose>
    			<when test="title !=null and title != '' ">
    				and lower(title) like lower(#{title})
    			</when>
    			<when test="style !=null and style != '' ">
    				and style = #{style}
    			</when>
    			<otherwise>
    				and featured = true
    			</otherwise>
    		</choose>
    </select>
    
    <!-- 动态修补SQL  1.状态 or 2.检索title键字 or featured关键字 -->
    <select id="selectBlogByCondition" parameterType="int" resultType="Blog">
    	select * from blog  
    	<where>
    		<if test="state !=null and state != '' ">
    		   state = #{state}
    		</if>
    		<if test="title !=null and title != '' ">
    			and lower(title) like lower(#{title})
    		</if>
    		<if test="featured !=null ">
    			and featured = #{featured}
    		</if>
    	</where>
    </select>
    
     <!-- 按需修改列值，其余不变 ，set会自动去掉多余的逗号-->
    <update id="updateBlogByCondition" parameterType="Blog" >
    	update
    		 blog  
    	<set>
    		<if test="title != null ">title = #{title},</if>
    		<if test="authorId != null ">authorId = #{authorId},</if>
    		<if test="state != null ">state = #{state},</if>
    		<if test="style != null ">style = #{style},</if>
    		<if test="featured != null ">featured = #{featured}</if>					
    	</set>
    	where id = #{id};
    </update>
    
     <!-- trim版本，在前缀 where 后去掉多余的 and 或者 or
     	动态修补SQL  1.状态 or 2.检索title键字 or featured关键字 -->
    <select id="selectBlogByConditionTrim" parameterType="int" resultType="Blog">
    	select * from blog  
    	<trim prefix="where" prefixOverrides="and | or ">
    		<if test="state !=null and state != '' ">
    		   state = #{state}
    		</if>
    		<if test="title !=null and title != '' ">
    			and lower(title) like lower(#{title})
    		</if>
    		<if test="featured !=null ">
    			and featured = #{featured}
    		</if>
    	</trim>
    </select>
    
     <!-- trim 版本,在后缀 set 后去掉多余的逗号；
     	注意：前prefix,后suffix
     	按需修改列值，其余不变 ，set会自动去掉多余的逗号-->
    <update id="updateBlogByConditionTrim" parameterType="Blog" >
    	update
    		 blog  
    	<trim prefix="set" suffixOverrides=",">
    		<if test="title != null ">title = #{title},</if>
    		<if test="authorId != null ">authorId = #{authorId},</if>
    		<if test="state != null ">state = #{state},</if>
    		<if test="style != null ">style = #{style},</if>
    		<if test="featured != null ">featured = #{featured}</if>					
    	</trim>
    	where id = #{id};
    </update>
	
	<delete id="deleteBlogList"  parameterType="Blog">
		delete from blog where id in 
		<foreach collection="list" item="item" open="(" close=")" separator=",">
			#{item}
		</foreach>
	</delete>
	
	<resultMap type="Blog" id="blogResultMapNestd">
		<id column="blog_id" property="id"></id>
		<result column="blog_title" property="title"></result>
		<result column="blog_state" property="state"></result>
		<result column="blog_featured" property="featured"></result>
		<result column="blog_style" property="style"></result>
		<association column="blog_authorId" property="author" javaType="Author">
			<id column="author_id" property="id"/>
		    <result column="author_username" property="username"/>
		    <result column="author_password" property="password"/>
		    <result column="author_email" property="email"/>
		    <result column="author_bio" property="bio"/>
		    <result column="author_favouriteSection" property="favouriteSection"/>
		    <result column="author_nicknam" property="nicknam"/>
		    <result column="author_realname" property="realname"/>
		</association>
	</resultMap>
	<select id="selectBlogListNested" resultMap="blogResultMapNestd">
	SELECT  
		b.id AS blog_id,
		b.title AS blog_title,
		b.authorId AS blog_authorId,
		b.state AS blog_state,
		b.featured AS blog_featured,
		b.style AS blog_style,
		
		a.id AS author_id,
		a.username AS author_username,
		a.password AS author_password,
		a.email AS author_email,
		a.bio AS author_bio,
		a.favouriteSection AS author_favouriteSection,
		a.nicknam AS author_inicknam,
		a.realname AS author_realname
		
		FROM blog b
		LeFT JOIN author a
		ON  b.authorId = a.id
	</select>
	
	<!-- 构造方法映射 -->
	<resultMap type="Blog" id="blogResultMapConstructor">
		<constructor>
			<idArg column="id" javaType="int"/>
			<arg column="title" javaType="string"/>
		</constructor>
	</resultMap>
	<select id="selectBlogByIdConstructor" parameterType="int" resultMap="blogResultMapConstructor">
		select * from blog where id = #{id}
	</select>
	
</mapper> 